package com.snapdeal.service.Impl;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.annotation.PostConstruct;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.monetization.constant.ScheduledRuleConstant;
import com.snapdeal.POJO.ScheduledProcessInfo;
import com.snapdeal.dao.SFCBDAO;
import com.snapdeal.dao.impl.SFCBDAOImpl;
import com.snapdeal.monetization.base.queue.producer.MonetizationQueueProducer;
import com.snapdeal.monetization.common.CBESfcbInputTo;
import com.snapdeal.monetization.common.CBESupcProcessInputTo;
import com.snapdeal.monetization.common.SfcbEvent;
import com.snapdeal.monetization.common.SfcbModel;
import com.snapdeal.monetization.ps.commons.SourceName;
import com.snapdeal.monetization.ps.constant.Constants;
import com.snapdeal.service.CashbackKafkaService;
import com.snapdeal.service.PSService;
import com.snapdeal.service.SFCBService;

import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;
import database.DataSource;

@Service("sfcbService")
public class SFCBServiceImpl implements SFCBService {
	private static final Logger	logger	= Logger.getLogger(SFCBServiceImpl.class);
	@Value("${sfcbSheetProducerThreads:1}")
	private Integer				PROD_SIZE;
	@Value("${sfcbSheetConsumerThreads:2}")
	private Integer				CONS_SIZE;
	
	@Value("${sfcbTriggerStartConsumerThreads:2}")
	private Integer				startTriggers;
	
	@Value("${sfcbTriggerEndConsumerThreads:2}")
	private Integer				endTriggers;

	public BlockingQueue<SfcbEvent> queue;

	@Autowired
	private SFCBDAO			sfcbDao;
	@Autowired
	private PSService		psService;
	@Autowired
	CashbackKafkaService	cashbackKafkaServiceImpl;

	@Autowired
	private MonetizationQueueProducer lowPriorityQueue;

	private ExecutorService consumerService = null;
	ExecutorService startSchedulerService = null;
	ExecutorService endSchedulerService = null;
	
	@PostConstruct
	public void init() {
		queue = new LinkedBlockingQueue<>(100000);

		consumerService = Executors.newFixedThreadPool(CONS_SIZE, new ThreadFactory() {
			private AtomicInteger count = new AtomicInteger(1);

			@Override
			public Thread newThread(Runnable r) {
				return new Thread(r, "sfcb-cons-" + count.getAndIncrement());
			}
		});

		initializeConsumerThreads();
	}

	private void initializeConsumerThreads() {
		for (int i = 0; i < CONS_SIZE; ++i) {
			consumerService.submit(new SfcbValidEventConsumerThread(queue, sfcbDao));
		}
	}

	@Value("${sfcbSheetMaxSize:100000}")
	private Integer sfcbSheetMaxSize;

	public String parseFile(CSVReader csvReader, String uploadType, String uploadId) {
		try {
			logger.info("SFCB file uploaded with type " + uploadType);
			long time = System.nanoTime();
			Set<SfcbEvent> set = new HashSet<>();

			int counter = 2;
			StringBuilder errorMessages = new StringBuilder();
			String returnedValue = null;
			SFCBVBSAddTask sfcbvbsAddTask = new SFCBVBSAddTask();
			SFCBSellerSupcAddTask sFCBSellerSupcAddTask = new SFCBSellerSupcAddTask();
			SFCBVBSDeleteTask sFCBVBSDeleteTask = new SFCBVBSDeleteTask();
			SFCBSellerSupcDeleteTask sFCBSellerSupcDeleteTask = new SFCBSellerSupcDeleteTask();

			String row[] = null;
			row = csvReader.readNext();
			while (((row = csvReader.readNext()) != null) && counter <= sfcbSheetMaxSize) {
				switch (uploadType) {
				case Constants.UploadVBS:
					returnedValue = sfcbvbsAddTask.processAndSendSfcbEvent(row, uploadId, queue, set, counter);
					break;
				case Constants.UploadSellerSUPC:
					returnedValue = sFCBSellerSupcAddTask.parseAndSendSfcbEvent(row, uploadId, queue, set, counter);
					break;
				case Constants.DeleteVBS:
					returnedValue = sFCBVBSDeleteTask.parseAndSendSfcbEvent(row, uploadId, queue, set, counter);
					break;
				case Constants.DeleteSellerSUPC:
					returnedValue = sFCBSellerSupcDeleteTask.parseAndSendSfcbEvent(row, uploadId, queue, set, counter);
					break;
				default:
					logger.warn("Invalid SFCB upload type");
				}
				counter++;
				if (!Constants.SUCCESS.equals(returnedValue)) {
					errorMessages.append(returnedValue);
				}
			}
			if (counter >= 100001) {
				returnedValue = returnedValue + "\n Error: The file size is greater than 100k  thus rows greater after 100k will be rejected ";
				logger.info("The file size is greater than 100k  for file :" + uploadId);
			}

			String message = errorMessages.length() > 0 ? errorMessages.toString() : Constants.SUCCESS;
			logger.info("SFCB file processing takes time " + (System.nanoTime() - time) + " ns, with message:: [" + message + "]");
			return message;
		} catch (FileNotFoundException e) {
			logger.error("Error occured while traversing or inserting into queue", e);
			return e.getMessage();
		} catch (IOException e) {
			logger.error("Error occured while traversing or inserting into queue", e);
			return e.getMessage();
		} catch (Exception e) {
			logger.error("Error occured while traversing or inserting into queue", e);
			return e.getMessage();
		}
	}

	@Override
	public File downloadFile(String type) {
		String sheetName = Constants.DB_DUMP_SHEET_NAME;
		File file = new File(sheetName);
		try {
			CSVWriter csvWriter = new CSVWriter(new FileWriter(file));
			if (type.equals(Constants.DownloadVBS)) {
				csvWriter.writeNext(new String[] { "VendorCode", "VendorName", "BrandId", "BrandName", "SubcatId", "SubcatName", "CategoryName","pcbLimit",
						"BrandDiscount", "Email", "StartDate", "EndDate" });
				sfcbDao.fetchVBSDump(csvWriter);
			} else if (type.equals(Constants.DownloadSellerSupc)) {
				csvWriter.writeNext(new String[] { "Supc", "VendorCode", "Final Margin", "PCBLimit", "Brand_Id", "Brand_Name", "Subcategory_Id",
						"Subcategory_Name", "Category_Id", "Category_Name", "Vendor_Name", "Type-SOR/SOI/OR", "BrandDiscount", "Pog", "SellingPrice",
						"Email", "TimeStamp", "StartDate", "EndDate", "SDVBSMargin", "MaxDiscountLimit" });
				sfcbDao.fetchSellerSupcDump(csvWriter);
			}
			csvWriter.close();
		} catch (Exception e) {
			logger.error("Error compiling Dump Excel for SellerSupc: ", e);
		}
		return file;

	}

	

	public PSService getPsService() {
		return psService;
	}

	public void setPsService(PSService psService) {
		this.psService = psService;
	}

	@Override
	public File createZipFile(File file) {
		logger.info("Inside createZipFile() for creating zip file for dump file");
		File fileOut = new File("DBDump.zip");
		try {

			FileOutputStream fileOutputStream = new FileOutputStream(fileOut.getName());
			ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream);
			ZipEntry zipEntry = new ZipEntry(file.getName());
			zipOutputStream.putNextEntry(zipEntry);
			FileInputStream fileInputStream = new FileInputStream(file.getName());
			byte[] buf = new byte[1024];
			int bytesRead;

			while ((bytesRead = fileInputStream.read(buf)) > 0) {
				zipOutputStream.write(buf, 0, bytesRead);
			}
			zipOutputStream.closeEntry();
			zipOutputStream.close();
			fileInputStream.close();

		} catch (Exception e) {
			logger.error("Error occured inside createZipFile() ::" + ExceptionUtils.getStackTrace(e));
		}
		return fileOut;
	}

	@Override
	public SfcbEvent getPojoForRuleId(Integer id, String tableName) {
		logger.info("inside getPojoForRuleId for id : " + id + " for tableName : " + tableName);
		SfcbEvent sfcbEvent = null;

		if (tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC)) {
			sfcbEvent = sfcbDao.getPojoForRuleIdSellerSupc(id);
		} else {
			sfcbEvent = sfcbDao.getPojoForRuleIdVBS(id);
		}
		return sfcbEvent;
	}
	
	@Override
	public void loadSfcbSellerSupcCacheMap() {
		logger.info("inside loadSfcbSellerSupcCacheMap");
		ArrayList<CBESfcbInputTo> cbeSfcbInputTos =  sfcbDao.getSfcbSellerSupcData();
		for (CBESfcbInputTo data : cbeSfcbInputTos) {
			sfcbDao.putSfcbSellerSupcMapData(data);
		}
	}
	
	@Override
	public void loadSfcbVbsCacheMap() {
		logger.info("inside loadSfcbVbsCacheMap");
		ArrayList<CBESfcbInputTo> cbeSfcbInputTos =  sfcbDao.getSfcbSellerVbsData();
		for (CBESfcbInputTo data : cbeSfcbInputTos) {
			sfcbDao.putSfcbVbsMapData(data);
		}
	}

	@Override
	public void endJob(Integer id, String tableName) {
		logger.info("sfcb end Trigger for id :" + id + " and tableName: " + tableName);
		SfcbEvent sfcbEvent = getPojoForRuleId(id, tableName);
		if (sfcbEvent != null) {

			endJobDaoOperation(id, sfcbEvent, tableName);

			CBESfcbInputTo cBESfcbInputTo = new CBESfcbInputTo();
			setPojoForAero(id, tableName, sfcbEvent, cBESfcbInputTo);

			performAeroOperation(id, tableName, cBESfcbInputTo,SFCBDAOImpl.ENDED);

			List<String> supcs = null;

			if (tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC)) {
				supcs = new ArrayList<>();
				supcs.add(sfcbEvent.getSupc());
			} else {
				supcs = getSupcSellerForVBS(sfcbEvent);
				if (supcs == null) {
					logger.info("no supc for the given vendor brand subcat is vsvp");
					return;
				}
			}

			Map<String, HashMap<Integer, CBESupcProcessInputTo>> outMap = getProcessMapForVendorSupcs(supcs, sfcbEvent);

			pushToCBEViaKafka(sfcbEvent, outMap);
		} else {
			logger.info("no sfcbEvent received for id :" + id + " and tableName: " + tableName);
		}
	}

	private void pushToCBEViaKafka(SfcbEvent sfcbEvent, Map<String, HashMap<Integer, CBESupcProcessInputTo>> outMap) {
		if (null != outMap && !outMap.isEmpty()) {
			for (String supc : outMap.keySet()) {
				logger.info("inside pushToCBEViaKafka for supc : " + supc);
				if (outMap.get(supc) != null) {
					cashbackKafkaServiceImpl.produceGrouIdForCB(outMap.get(supc));
					logger.info("Event for cbe produced for supc  " + supc);
				} 
			}
		} else {
			logger.info("the Map received is empty");
		}
	}

	private void setPojoForAero(Integer id, String tableName, SfcbEvent sfcbEvent, CBESfcbInputTo cBESfcbInputTo) {
		if (tableName.equals(ScheduledRuleConstant.SFCB_VBS)) {

			cBESfcbInputTo.setAutoIncrementedId(id);
			cBESfcbInputTo.setBrandDiscount(sfcbEvent.getBrandDiscount());
			cBESfcbInputTo.setSubcatId(sfcbEvent.getSubcatId());
			;
			cBESfcbInputTo.setBrandId(sfcbEvent.getBrandId());
			cBESfcbInputTo.setSeller(sfcbEvent.getSeller());
			cBESfcbInputTo.setMaxDiscount(100);
			cBESfcbInputTo.setUploadId(sfcbEvent.getUploadId());
		} else {
			cBESfcbInputTo.setAutoIncrementedId(id);
			cBESfcbInputTo.setBrandDiscount(sfcbEvent.getBrandDiscount());
			cBESfcbInputTo.setSupc(sfcbEvent.getSupc());
			cBESfcbInputTo.setSeller(sfcbEvent.getSeller());
			cBESfcbInputTo.setMaxDiscount(sfcbEvent.getMaxBrandDiscount());
			cBESfcbInputTo.setUploadId(sfcbEvent.getUploadId());
		}
	}

	private List<String> setSupcs(String tableName, SfcbEvent sfcbEvent) {
		List<String> supcs = null;

		if (tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC)) {
			supcs = new ArrayList<>();
			supcs.add(sfcbEvent.getSupc());
		} else {
			supcs = getSupcSellerForVBS(sfcbEvent);
		}
		return supcs;
	}

	@Override
	public void startJob(Integer id, String tableName) {
		logger.info("sfcb start Trigger for id :" + id + " and tableName: " + tableName);
		SfcbEvent sfcbEvent = getPojoForRuleId(id, tableName);
		if (sfcbEvent != null) {
			startJobDaoOperation(id, sfcbEvent, tableName);

			CBESfcbInputTo cBESfcbInputTo = new CBESfcbInputTo();
			setPojoForAero(id, tableName, sfcbEvent, cBESfcbInputTo);

			performAeroOperation(id, tableName, cBESfcbInputTo,SFCBDAOImpl.STARTED);

			List<String> supcs = null;

			if (tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC)) {
				supcs = new ArrayList<>();
				supcs.add(sfcbEvent.getSupc());
			} else {
				supcs = getSupcSellerForVBS(sfcbEvent);
				if (supcs == null) {
					logger.info("no supc for the given vendor brand subcat is vsvp");
					return;
				}
			}

			Map<String, HashMap<Integer, CBESupcProcessInputTo>> outMap = getProcessMapForVendorSupcs(supcs, sfcbEvent);

			pushToCBEViaKafka(sfcbEvent, outMap);
		} else {
			logger.info("no entry present in sfcb table : " + tableName + " for the given id : " + id);
		}
	}

	private Boolean performAeroOperation(Integer id, String tableName, CBESfcbInputTo cBESfcbInputTo,String action) {
		logger.info("inside aero operations for id : "+id+" for tableName : "+tableName+" for action : "+action+" with event :"+cBESfcbInputTo.toString());
		
		if(tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC) && action.equals(SFCBDAOImpl.STARTED))
		{
			if(!sfcbDao.putSfcbSellerSupcMapData(cBESfcbInputTo))
			{
				logger.error("error while uploading data into aerospike for id : "+id+" and tableName : "+tableName);
				return false;
			}
		}
		else if(tableName.equals(ScheduledRuleConstant.SFCB_VBS) && action.equals(SFCBDAOImpl.STARTED))
		{
			if(!sfcbDao.putSfcbVbsMapData(cBESfcbInputTo))
			{
				logger.error("error while uploading data into aerospike for id : "+id+" and tableName : "+tableName);
				return false;
			}
		}
		else if(tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC) &&  action.equals(SFCBDAOImpl.ENDED))
		{
			if(!sfcbDao.removeSfcbSellerSupcMapData(cBESfcbInputTo))
			{
				logger.error("error while uploading data into aerospike for id : "+id+" and tableName : "+tableName);
				return false;
			}
		}
		else
		{
			if(!sfcbDao.removeSfcbVbsMapData(cBESfcbInputTo))
			{
				logger.error("error while uploading data into aerospike for id : "+id+" and tableName : "+tableName);
				return false;
			}
		}
		
		return true;
	}

	@Override
	public List<String> getSupcSellerForVBS(SfcbEvent sfcbEvent) {

		List<String> list = sfcbDao.getSupcSellerFromVSVP(sfcbEvent);
		return list;
	}

	@Override
	public Map<String, HashMap<Integer, CBESupcProcessInputTo>> getProcessMapForVendorSupcs(List<String> supcs, SfcbEvent sfcbEvent) {
		logger.info("Inside getProcessMapForVendorSupcs for sfcb event : " + sfcbEvent);
		Map<String, HashMap<Integer, CBESupcProcessInputTo>> map = new HashMap<>();
		Connection connection = null;
		PreparedStatement statement = null;
		ResultSet set = null;

		for (String supc : supcs) {
			logger.info(" will fetch ps group pui data for supc and seller : " + supc + " and" + sfcbEvent.getSeller());
			try {
				connection = DataSource.getInstance().getConnection();
				statement = connection.prepareStatement(
						"SELECT psg.groupId,pui.status,psg.source_id FROM ps_user_input pui JOIN ps_group psg ON pui.groupId=psg.groupId WHERE pui.supc = ? and pui.vendorCode = ? ");
				statement.setString(1, supc);
				statement.setString(2, sfcbEvent.getSeller());
				set = statement.executeQuery();
				if (set.next()) {
					Integer groupId = set.getInt(1);
					String vendorCode = sfcbEvent.getSeller();
					Integer status = set.getInt(2);
					Integer sourceId = set.getInt(3);
					if (map.containsKey(supc)) {
						psService.insertIntoMapSendToCashback(map.get(supc), groupId, supc, vendorCode, status, sourceId);
					} else {
						map.put(supc, new HashMap<Integer, CBESupcProcessInputTo>());
						psService.insertIntoMapSendToCashback(map.get(supc), groupId, supc, vendorCode, status, sourceId);
					}
				} else {
					Integer groupId = sfcbDao.createPSGroupPUIEntries(supc, sfcbEvent);
					if (groupId != null) {
						if (map.containsKey(supc)) {
							psService.insertIntoMapSendToCashback(map.get(supc), groupId, supc, sfcbEvent.getSeller(), 0,
									SourceName.SFCB.getSourceId());
						} else {
							map.put(supc, new HashMap<Integer, CBESupcProcessInputTo>());
							psService.insertIntoMapSendToCashback(map.get(supc), groupId, supc, sfcbEvent.getSeller(), 0,
									SourceName.SFCB.getSourceId());
						}
					} else {
						logger.info("group id received is empty for supc : " + supc + " and for event :" + sfcbEvent);
					}
				}
			} catch (Exception e) {
				logger.error("Error while reading data from psGroup PUI for sfcb triggers : " + ExceptionUtils.getStackTrace(e));
			} finally {
				if (set != null) {
					try {
						set.close();
					} catch (SQLException e) {
						logger.error(e);
					}
				}
				if (statement != null) {
					try {
						statement.close();
					} catch (SQLException e) {
						logger.error(e);
					}
				}
				if (connection != null) {
					try {
						connection.close();
					} catch (SQLException e) {
						logger.error(e);
					}
				}
			}

		}
		return map;
	}

	@Override
	public Boolean startJobDaoOperation(Integer id, SfcbEvent sfcbEvent, String tableName) {
		logger.info("inside startJobDaoOperation for id : " + id + " for tableName : " + tableName + " for event : " + sfcbEvent.toString());
		if (id != null) {
			
				if (tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC)) {
					sfcbDao.recordJobActionInHistorySellerSupc(sfcbEvent, SFCBDAOImpl.STARTED);
				} else if (tableName.equals(ScheduledRuleConstant.SFCB_VBS)) {
					sfcbDao.recordJobActionInHistoryVBS(sfcbEvent, SFCBDAOImpl.STARTED);
				}
				return true;
		} else {
			logger.info(" rule id is null ");
		}
		return false;
	}

	@Override
	public Boolean endJobDaoOperation(Integer id, SfcbEvent sfcbEvent, String tableName) {
		logger.info("inside endJobDaoOperation for id : " + id + " for tableName : " + tableName + " for event : " + sfcbEvent.toString());
		if (id != null) {
			if (sfcbDao.endJob(id, tableName)) {
				if (tableName.equals(ScheduledRuleConstant.SFCB_SELLER_SUPC)) {
					sfcbDao.recordJobActionInHistorySellerSupc(sfcbEvent, SFCBDAOImpl.ENDED);
				} else if (tableName.equals(ScheduledRuleConstant.SFCB_VBS)) {
					sfcbDao.recordJobActionInHistoryVBS(sfcbEvent, SFCBDAOImpl.ENDED);
				}
				return true;
			}
		} else {
			logger.info(" rule id is null ");
		}
		return false;
	}

	@Override
	public SfcbModel getSfcbModelFromAero(String supc, String vendor_code, int subcat_id, int brand_id) {

		SfcbModel sfcbModel = null;

		sfcbModel = sfcbDao.getSFCBSellerSupcFromAero(supc, vendor_code);
		if (sfcbModel == null) {
			return sfcbDao.getSFCBVBSFromAero(vendor_code, subcat_id, brand_id);
		} else {
			return sfcbModel;
		}
	}

	@Override
	public void invokeStartSfcbWatcher() {
		logger.info("Invoking StartSfcbWatcher");
		Thread watcherThread = new Thread(new StartSfcbWatcherTask());
		startSchedulerService = Executors.newFixedThreadPool(startTriggers);
		watcherThread.start();
		logger.info("StartSfcbWatcher started");
	}

	@Override
	public void invokeEndSfcbWatcher() {
		logger.info("Invoking endSfcbWatcher");
		Thread watcherThread = new Thread(new EndSfcbWatcherTask());
		endSchedulerService = Executors.newFixedThreadPool(endTriggers);
		watcherThread.start();
		logger.info("EndSfcbWatcher started");
	}


	class SfcbStartSchedulerConsumer implements Runnable {

		Integer	id;
		String	tableName;

		@Override
		public void run() {

			startJob(id, tableName);
		}
	}
	
	class SfcbEndSchedulerConsumer implements Runnable{

		Integer	id;
		String	tableName;

		@Override
		public void run() {

			endJob(id, tableName);
		}
		
	}
	
	
	
	class StartSfcbWatcherTask implements Runnable {

		@Override
		public void run() {

			while (true) {
				List<Integer> ids = sfcbDao.getSFCBSchedulesBySellerSupcStartTime();
				for (Integer id : ids) {
					sfcbDao.startJob(id, ScheduledRuleConstant.SFCB_SELLER_SUPC);
					SfcbStartSchedulerConsumer task = new SfcbStartSchedulerConsumer();
					task.id = id;
					task.tableName = ScheduledRuleConstant.SFCB_SELLER_SUPC;
					startSchedulerService.submit(task);
				}

				ids = sfcbDao.getSFCBSchedulesByVBSStartTime();
				for (Integer id : ids) {
					sfcbDao.startJob(id, ScheduledRuleConstant.SFCB_VBS);
					SfcbStartSchedulerConsumer task = new SfcbStartSchedulerConsumer();
					task.id = id;
					task.tableName = ScheduledRuleConstant.SFCB_VBS;
					startSchedulerService.submit(task);
				}

				try {
					Thread.sleep(10000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}

	}

	class EndSfcbWatcherTask implements Runnable {

		@Override
		public void run() {
			while (true) {
				List<Integer> ids = sfcbDao.getSFCBSchedulesBySellerSupcEndTime();
				for (Integer id : ids) {
					SfcbEndSchedulerConsumer task = new SfcbEndSchedulerConsumer();
					task.id = id;
					task.tableName = ScheduledRuleConstant.SFCB_SELLER_SUPC;
					endSchedulerService.submit(task);
				}

				ids = sfcbDao.getSFCBSchedulesByVBSEndTime();
				for (Integer id : ids) {
					SfcbEndSchedulerConsumer task = new SfcbEndSchedulerConsumer();
					task.id = id;
					task.tableName = ScheduledRuleConstant.SFCB_VBS;
					endSchedulerService.submit(task);
				}

				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}	

	